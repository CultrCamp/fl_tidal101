#![allow(unused_imports)]

use crate::tokio;
use prost::Message;
use rinf::{debug_print, send_rust_signal, DartSignal, RinfError};
use std::sync::Mutex;
use tokio::sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender};


// @generated
// This file is @generated by prost-build.
/// \[RINF:DART-SIGNAL\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmallText {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
}
/// \[RINF:RUST-SIGNAL\]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmallNumber {
    #[prost(int32, tag="1")]
    pub number: i32,
}
// @@protoc_insertion_point(module)

type SmallTextCell = Mutex<Option<(
    UnboundedSender<DartSignal<SmallText>>,
    Option<UnboundedReceiver<DartSignal<SmallText>>>,
)>>;
pub static SMALL_TEXT_CHANNEL: SmallTextCell =
    Mutex::new(None);

impl SmallText {
    pub fn get_dart_signal_receiver()
        -> Result<UnboundedReceiver<DartSignal<Self>>, RinfError> 
    {       
        let mut guard = SMALL_TEXT_CHANNEL
            .lock()
            .map_err(|_| RinfError::LockMessageChannel)?;
        if guard.is_none() {
            let (sender, receiver) = unbounded_channel();
            guard.replace((sender, Some(receiver)));
        }
        let (mut sender, mut receiver_option) = guard
            .take()
            .ok_or(RinfError::NoMessageChannel)?;
        // After Dart's hot restart or app reopen on mobile devices,
        // a sender from the previous run already exists
        // which is now closed.
        if sender.is_closed() {
            let receiver;
            (sender, receiver) = unbounded_channel();
            receiver_option = Some(receiver);
        }
        let receiver = receiver_option.ok_or(RinfError::MessageReceiverTaken)?;
        guard.replace((sender, None));
        Ok(receiver)
    }
}

impl SmallNumber {
    pub fn send_signal_to_dart(&self) {
        let result = send_rust_signal(
            1,
            self.encode_to_vec(),
            Vec::new(),
        );
        if let Err(error) = result {
            debug_print!("{error}\n{self:?}");
        }
    }
}
